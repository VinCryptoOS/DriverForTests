Что сделать
Проверить и закончить документацию
Возможно, стоит сделать архивацию по флагу или с атрибутом


# Содержимое
Основная библиотека в папке DriverForTests
Пример действий показан в подпапке Tests.

В DriverForTests основной файл - DriverForTests.cs


# Использование тестов

## Запуск тестов
1. Переопределить асбтрактный класс-конструктор тестов, например:
[Example1TestConstructor : TestConstructor](../Tests/Program_AddTasks.cs)

2. Реализовать в нём CreateTasksLists

3. Для автоматической постановки задач по атрибутам применить методы
    TestConstructor.getTasksFromAppDomain
    TestConstructor.addTasksForQueue
    
    как это показано в файле [../Tests/Program_AddTasks.cs](../Tests/Program_AddTasks.cs)
    
    В процессе, который выполняет задачи, должна быть ссылка <ProjectReference Include=...> на тестируемую сборку
    Для того, чтобы сборка подгрузилась, возможно, придётся обратиться к любому её классу (например, статическому полю)

4. Для ручной постановки задач использовать "tasks.Enqueue(t)" в том же методе CreateTasksLists

5. Если нужно, необходимо определить в наследнике TestConstructor условие conditions на выполняемые тесты.
    Регистрация задач для тестов всегда полная, без фильтрации. Перед тестами проверяются conditions.
    См. также класс [TestConditionParser](./TestTask-parser.cs)

6. Для запуска тестов вызвать driver.ExecuteTests( new Example1TestConstructor() );
    где Example1TestConstructor - это класс-фабрика, в котором был переопределён метод CreateTasksLists

## Создание класса, определяющего задачу тестирования

1. Отнаследовать новую задачу на тест от класса TestTask. 
    Передать в base-конструктор имя задачи. Это имя можно потом изменить, если это нужно

2. Если нужно, поставить на задачу атрибут TestTagAttribute
Например:
[TestTagAttribute("", double.MaxValue, singleThread: true, notAutomatic: true)]
class TestSingleThread_1: TestTask

Атрибут можно поставить несколько раз

3. Написать для задачи taskFunc

4. Если тест завершается с ошибой, он должен добавить ошибку в свой список ошибок
    var error = new TestError();
    this.error.Add(error);

    Пример генерации ошибки тестирования есть в файле [../Tests/ExampleTasks.cs](../Tests/ExampleTasks.cs) в классе TestSlowAndFastAndMedium_1

    Генерация необработанного исключения в задаче автоматически регистрирует ошибку

## Реализация AutoSaveTask

1. Отнаследовать новую задачу от AutoSaveTestTask
    Навесить неавтоматический атрибут [TestTagAttribute(notAutomatic: true)] (с тегами или без)
    (или вообще не навешивать атрибуты)
    Задача всегда будет неавтоматической, т.к. ей нужно передавать параметр CanCreate (хотя, можно извратиться и сделать передачу CanCreate непосредственно в определении класса задачи)
    Задать директорию для сохранения тестовых файлов

    [TestBytes_TestTask](../Tests/ExampleTasks.cs) - пример AutoSaveTestTask, которая не имеет атрибута "notAutomatic: true"

2. На объекты, которые не нужно сохранять в файлы и сверять, нужно поставить атрибут TaskResultSaver_DoNotSaveAttribute. Классы будут сохраняться целиком (публичные поля), если атрибут поставлен на полях, значит эти поля не сохранятся. Индексаторы не сохраняются никогда. Для сохранения коллекций поле должно реализовывать интерфейс IEnumerable.

3. Вручную зарегистрировать задачи, аналогично обычным задачам

4. При наследовании в поле executer_and_saver.canCreateFile поставить true, чтобы сгенерировать тестовые файлы в первый раз.
Лучше всего это дополнительно сопроводить #warning , чтобы в дальнейшем не забыть его убрать
При последующих запусках эти файлы уже не надо генерировать (исключая случаи внесения изменений в программу). Поэтому нужно убрать canCreateFile и запустить программу заново. Посмотреть, что все тесты прошли без ошибок: это означает, что программа действительно стабильно даёт один и тот же результат.
При этом нужно проверить, что в автоматически сгенерированных файлах действительно есть нужная информация

5. Задачи, которые окончились неуспехом, сохраняют свой вывод в файл, к которому добавляется ".error"
